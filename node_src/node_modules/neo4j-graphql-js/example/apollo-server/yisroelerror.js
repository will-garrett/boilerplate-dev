export const typeDefs = [`

  type Type {
      id: ID!
      name: String!
#      fromAssns: [Assn]  @cypher(statement:"MATCH (this)<-[:HAS_A]-(a:Assn) RETURN a")
      assns: [Assn] @relation(name: "HAS_A", direction: "OUT")
    platform: [Platform] @relation(name: "FOR", direction: "OUT")
  }  
  
  type Assn {
      id: ID!
      name: String
      types: [Type]    @cypher(statement: "MATCH (this)<-[:HAS_A]->(t:Type) RETURN t")
  }

  type Platform {
    name: ID
  }
  

  type Query {
      optionsForPath(treeType: ID, newType: ID): String @cypher(statement: "MATCH p=(fromType:Type{id:$treeType})-[r:HAS_A*]-(toType:Type{id:$newType}) RETURN p")
  }
  `];

  export const resolvers = {
    Query: {
      optionsForPath: neo4jgraphql
    }
  };


import { augmentSchema, neo4jgraphql } from '../../src/index';
import { ApolloServer } from 'apollo-server-express';
import express from 'express';
import bodyParser from 'body-parser';
import { makeExecutableSchema } from 'apollo-server';
import { v1 as neo4j } from 'neo4j-driver';


const schema = makeExecutableSchema({
  typeDefs,
  resolvers,
  resolverValidationOptions: {
    requireResolversForResolveType: false
  }
});

// Add auto-generated mutations
const augmentedSchema = augmentSchema(schema);

const driver = neo4j.driver(
  process.env.NEO4J_URI || 'bolt://localhost:7687',
  neo4j.auth.basic(
    process.env.NEO4J_USER || 'neo4j',
    process.env.NEO4J_PASSWORD || 'letmein'
  )
);

const app = express();
app.use(bodyParser.json());

const checkErrorHeaderMiddleware = async (req, res, next) => {
  req.error = req.headers['x-error'];
  next();
};

app.use('*', checkErrorHeaderMiddleware);

const server = new ApolloServer({
  schema: augmentedSchema,
  // inject the request object into the context to support middleware
  // inject the Neo4j driver instance to handle database call
  context: ({ req }) => {
    return {
      driver,
      req
    };
  }
});

server.applyMiddleware({ app, path: '/' });
app.listen(3000, '0.0.0.0');
